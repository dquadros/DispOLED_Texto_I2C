//
// Teste de escrita de texto com Display OLED
// baseado no controlador SSD1306
// Comunicação via I2C
//

#include <Wire.h>

// Endereço I2C do display
#define DISP_ADDR  0x3C

// Comandos
#define SSD1306_SETCONTRAST 0x81
#define SSD1306_DISPLAYALLON_RESUME 0xA4
#define SSD1306_DISPLAYALLON 0xA5
#define SSD1306_NORMALDISPLAY 0xA6
#define SSD1306_INVERTDISPLAY 0xA7
#define SSD1306_DISPLAYOFF 0xAE
#define SSD1306_DISPLAYON 0xAF
#define SSD1306_SETDISPLAYOFFSET 0xD3
#define SSD1306_SETCOMPINS 0xDA
#define SSD1306_SETVCOMDETECT 0xDB
#define SSD1306_SETDISPLAYCLOCKDIV 0xD5
#define SSD1306_SETPRECHARGE 0xD9
#define SSD1306_SETMULTIPLEX 0xA8
#define SSD1306_SETLOWCOLUMN 0x00
#define SSD1306_SETHIGHCOLUMN 0x10
#define SSD1306_SETSTARTLINE 0x40
#define SSD1306_MEMORYMODE 0x20
#define SSD1306_COLUMNADDR 0x21
#define SSD1306_PAGEADDR   0x22
#define SSD1306_COMSCANINC 0xC0
#define SSD1306_COMSCANDEC 0xC8
#define SSD1306_SEGREMAP 0xA0
#define SSD1306_CHARGEPUMP 0x8D
#define SSD1306_EXTERNALVCC 0x1
#define SSD1306_SWITCHCAPVCC 0x2

// Tamanho da tela
#define SSD1306_LCDWIDTH                  128
#define SSD1306_LCDHEIGHT                 64

// Iniciação
void setup() {
  Wire.begin();
  Display_init();
}

// Laço principal
void loop() {
  Teste_6x8();
  delay (10000);
  Teste_8x12();
  delay (10000);
  Teste_8x16();
  delay (10000);
}

void Teste_6x8() {
  Display_clear();
  Display_print_6x8 (0, 3, "FADA BEBE CAFE");
  byte dig = 0;
  for (byte l = 1; l < 7; l++) {
    for (byte c = 0; c < 20; c++) {
      Display_write_6x8 (l, c, dig);
      dig = (dig + 1) & 0x0F;
    }
  }
}

void Teste_8x12() {
  Display_clear_8x12();
  Display_print_8x12 (0, 1, "FADA BEBE CAFE");
  Display_print_8x12 (1, 0, "0123456789ABCDEF");
  Display_print_8x12 (2, 0, "23456789ABCDEF01");
  Display_print_8x12 (3, 0, "456789ABCDEF0123");
  Display_print_8x12 (4, 0, "6789ABCDEF012345");
}

void Teste_8x16() {
  Display_clear();
  Display_print_8x16 (0, 1, "FADA BEBE CAFE");
  byte dig = 0;
  for (byte l = 1; l < 4; l++) {
    for (byte c = 0; c < 16; c++) {
      Display_write_8x16 (l, c, dig);
      dig = (dig + 1) & 0x0F;
    }
    dig = (dig + 2) & 0x0F;
  }
}

/*********** Caracteres 6x8 **************/

// Fonte 6x8 (só dígitos hexadecimais)
const PROGMEM uint8_t font_6x8 [] = {
  0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
  0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, // 1
  0x00, 0x42, 0x61, 0x51, 0x49, 0x46, // 2
  0x00, 0x21, 0x41, 0x45, 0x4B, 0x31, // 3
  0x00, 0x18, 0x14, 0x12, 0x7F, 0x10, // 4
  0x00, 0x27, 0x45, 0x45, 0x45, 0x39, // 5
  0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
  0x00, 0x01, 0x71, 0x09, 0x05, 0x03, // 7
  0x00, 0x36, 0x49, 0x49, 0x49, 0x36, // 8
  0x00, 0x06, 0x49, 0x49, 0x29, 0x1E, // 9
  0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C, // A
  0x00, 0x7F, 0x49, 0x49, 0x49, 0x36, // B
  0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, // C
  0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C, // D
  0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, // E
  0x00, 0x7F, 0x09, 0x09, 0x09, 0x01  // F
};

// Escreve um "string hexadecimal" a partir da linha l(0 a 7), coluna c(0 a 19)
// Só para facilitar o teste
void Display_print_6x8 (byte l, byte c, char *str){
  while (*str) {
    if ((*str >= '0') && (*str <= '9')) {
      Display_write_6x8 (l, c, *str-'0');
    } else if ((*str >= 'A') && (*str <= 'F')) {
      Display_write_6x8 (l, c, *str-'A'+10);
    }
    c++;
    str++;
  }
}

// Escreve um digito hexadecimal na linha l(0 a 7), coluna c(0 a 19)
void Display_write_6x8 (byte l, byte c, byte dig) {
  uint8_t *gc = &font_6x8[dig*6];

  // Endereça o caracter
  Display_sendcmd (SSD1306_COLUMNADDR);
  Display_sendcmd (c*6);
  Display_sendcmd (c*6 + 5);
  Display_sendcmd (SSD1306_PAGEADDR);
  Display_sendcmd (l);
  Display_sendcmd (l);
  
  // Escreve
  Wire.beginTransmission(DISP_ADDR);
  Wire.write(0x40);  // Co=0, DC = 1
  for (uint8_t x = 0;  x < 6; x++) 
  {
      Wire.write(pgm_read_byte(gc++));
  }
  Wire.endTransmission();
}

/*********** Caracteres 8x16 **************/

// Fonte 8x16 (só dígitos hexadecimais)
const PROGMEM uint8_t font_8x16 [] = {
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x10, 0x0F, 0x00, // 0
    0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, // 1
    0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x30, 0x28, 0x24, 0x22, 0x21, 0x30, 0x00, // 2
    0x00, 0x30, 0x08, 0x88, 0x88, 0x48, 0x30, 0x00, 0x00, 0x18, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, // 3
    0x00, 0x00, 0xC0, 0x20, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x07, 0x04, 0x24, 0x24, 0x3F, 0x24, 0x00, // 4
    0x00, 0xF8, 0x08, 0x88, 0x88, 0x08, 0x08, 0x00, 0x00, 0x19, 0x21, 0x20, 0x20, 0x11, 0x0E, 0x00, // 5
    0x00, 0xE0, 0x10, 0x88, 0x88, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, // 6
    0x00, 0x38, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, // 7
    0x00, 0x70, 0x88, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x1C, 0x22, 0x21, 0x21, 0x22, 0x1C, 0x00, // 8
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x31, 0x22, 0x22, 0x11, 0x0F, 0x00, // 9
    0x00, 0x00, 0xC0, 0x38, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x3C, 0x23, 0x02, 0x02, 0x27, 0x38, 0x20, // A
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, // B
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x07, 0x18, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, // C
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, // D
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x23, 0x20, 0x18, 0x00, // E
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x00, 0x00, 0x00  // F
};

// Escreve um "string hexadecimal" a partir da linha l(0 a 3), coluna c(0 a 15)
// Só para facilitar o teste
void Display_print_8x16 (byte l, byte c, char *str){
  while (*str) {
    if ((*str >= '0') && (*str <= '9')) {
      Display_write_8x16 (l, c, *str-'0');
    } else if ((*str >= 'A') && (*str <= 'F')) {
      Display_write_8x16 (l, c, *str-'A'+10);
    }
    c++;
    str++;
  }
}

// Escreve um dígito hexadecimal na linha l(0 a 3), coluna c(0 a 15)
void Display_write_8x16 (byte l, byte c, byte dig)
{
  uint8_t *gc = &font_8x16[dig*16];

  // Endereça e escreve a parte de cima
  Display_sendcmd (SSD1306_COLUMNADDR);
  Display_sendcmd (c << 3);
  Display_sendcmd ((c << 3) + 7);
  Display_sendcmd (SSD1306_PAGEADDR);
  Display_sendcmd (l << 1);
  Display_sendcmd (l << 1);
  Wire.beginTransmission(DISP_ADDR);
  Wire.write(0x40);  // Co=0, DC = 1
  for (uint8_t x = 0;  x < 8; x++) 
  {
      Wire.write(pgm_read_byte(gc++));
  }
  Wire.endTransmission();

  // Endereça e escreve a parte de baixo
  Display_sendcmd (SSD1306_COLUMNADDR);
  Display_sendcmd (c << 3);
  Display_sendcmd ((c << 3) + 7);
  Display_sendcmd (SSD1306_PAGEADDR);
  Display_sendcmd ((l << 1) + 1);
  Display_sendcmd ((l << 1) + 1);
  Wire.beginTransmission(DISP_ADDR);
  Wire.write(0x40);  // Co=0, DC = 1
  for (uint8_t x = 0;  x < 8; x++) 
  {
      Wire.write(pgm_read_byte(gc++));
  }
  Wire.endTransmission();
}

/*********** Caracteres 8x12 **************/

// Cópia da imagem da tela na Ram
uint8_t tela [SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8];

// Copia uma página da Ram para o controlador
void copyPag (uint8_t pag) {
  int addr = pag << 7;  // pag * 128 = pag * SSD1306_LCDWIDTH
  Display_sendcmd (SSD1306_COLUMNADDR);
  Display_sendcmd (0);
  Display_sendcmd (SSD1306_LCDWIDTH-1);
  Display_sendcmd (SSD1306_PAGEADDR);
  Display_sendcmd (pag);
  Display_sendcmd (pag);
  for (uint16_t i = 0; i < SSD1306_LCDWIDTH/16; i++) 
  {
      Wire.beginTransmission(DISP_ADDR);
      Wire.write(0x40);  // Co=0, DC = 1
      for (uint8_t x=0; x<16; x++) 
      {
          Wire.write(tela[addr++]);
      }
      Wire.endTransmission();
  }
}

void Display_clear_8x12() {
  memset (tela, 0, sizeof(tela));
  Display_clear();
}

// Fonte 8x12 (só dígitos hexadecimais) 
const PROGMEM uint8_t font_8x12 [] = {
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00,  0x00, 0x03, 0x04, 0x08, 0x08, 0x04, 0x03, 0x00, // 0 ok
    0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00,  0x00, 0x08, 0x08, 0x0F, 0x08, 0x08, 0x08, 0x00, // 1 ok
    0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00,  0x00, 0x08, 0x0C, 0x0A, 0x09, 0x08, 0x08, 0x00, // 2 ok
    0x00, 0x10, 0x08, 0x48, 0x48, 0xA8, 0x10, 0x00,  0x00, 0x04, 0x08, 0x08, 0x08, 0x04, 0x07, 0x00, // 3 ok
    0x00, 0x80, 0x40, 0x20, 0x10, 0xF8, 0x00, 0x00,  0x00, 0x01, 0x01, 0x09, 0x09, 0x0F, 0x08, 0x00, // 4 ok
    0x00, 0xF8, 0x88, 0x48, 0x48, 0x88, 0x08, 0x00,  0x00, 0x04, 0x08, 0x08, 0x08, 0x04, 0x03, 0x00, // 5 ok
    0x00, 0xE0, 0x90, 0x48, 0x48, 0x90, 0x00, 0x00,  0x00, 0x03, 0x04, 0x08, 0x08, 0x04, 0x03, 0x00, // 6 ok
    0x00, 0x18, 0x08, 0x08, 0xC8, 0x28, 0x18, 0x00,  0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, // 7 ok
    0x00, 0x30, 0x48, 0x88, 0x88, 0x48, 0x30, 0x00,  0x00, 0x06, 0x09, 0x08, 0x08, 0x09, 0x06, 0x00, // 8 ok
    0x00, 0x60, 0x90, 0x08, 0x08, 0x90, 0xE0, 0x00,  0x00, 0x00, 0x08, 0x09, 0x09, 0x04, 0x03, 0x00, // 9 ok
    0x00, 0x00, 0xE0, 0x38, 0xE0, 0x00, 0x00, 0x00,  0x08, 0x0E, 0x09, 0x01, 0x09, 0x0E, 0x08, 0x00, // A ok
    0x08, 0xF8, 0x88, 0x88, 0xC8, 0xB0, 0x00, 0x00,  0x08, 0x0F, 0x08, 0x08, 0x08, 0x04, 0x03, 0x00, // B ok
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x08, 0x10, 0x00,  0x03, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00, // C .
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00,  0x08, 0x0F, 0x08, 0x08, 0x08, 0x04, 0x03, 0x00, // D .
    0x08, 0xF8, 0x88, 0x88, 0xC8, 0x08, 0x10, 0x00,  0x08, 0x0F, 0x08, 0x08, 0x09, 0x08, 0x04, 0x00, // E .
    0x08, 0xF8, 0x88, 0x88, 0xC8, 0x08, 0x10, 0x00,  0x08, 0x0F, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00  // F .
};

// Tabelas para facilitar o endereçamento
const int     addrLin[] = { 0x000, 0x100, 0x180, 0x280, 0x300};
const uint8_t pagLin [] = { 0, 2, 3, 5, 6};

// Escreve um "string hexadecimal" a partir da linha l(0 a 4), coluna c(0 a 15)
void Display_print_8x12 (byte l, byte c, char *str) {

  // Atualiza na Ram
  int addr = addrLin[l];
  while (*str != 0) {
    byte dig = 0xFF;
    if ((*str >= '0') && (*str <= '9')) {
      dig = *str-'0';
    } else if ((*str >= 'A') && (*str <= 'F')) {
      dig = *str-'A'+10;
    }
    if (dig != 0xFF) {
      uint8_t *gc = &font_8x12[dig*16];
      if ((l == 2) || (l == 4)) {
        // Alinhada em baixo
        for (int x = 0; x < 8; x++) {
          tela[addr+c*8+x] = (tela[addr+c*8+x] & 0x0F) | ((pgm_read_byte(gc+x) & 0x0F) << 4);
        }
        for (int x = 0; x < 8; x++) {
          tela[addr+0x80+c*8+x] = ((pgm_read_byte(gc+x) & 0xF0) >> 4) | ((pgm_read_byte(gc+x+8) & 0x0F) << 4);
        }
      } else {
        // Alinhada em cima
        for (int x = 0; x < 8; x++) {
          tela[addr+c*8+x] = pgm_read_byte(gc+x);
        }
        for (int x = 0; x < 8; x++) {
          tela[addr+0x80+c*8+x] = (tela[addr+0x80+c*8+x] & 0xF0) | (pgm_read_byte(gc+x+8) & 0x0F);
        }
      }
    }
    str++;
    c++;
  }

  // Copia para o controlador
  uint8_t pag = pagLin[l];
  copyPag (pag);
  copyPag (pag+1);
}


/*********** Parte Comum **************/

// Sequência de iniciação do display
byte cmdInit[] =
{
    SSD1306_DISPLAYOFF,
    SSD1306_SETDISPLAYCLOCKDIV, 0x80,
    SSD1306_SETMULTIPLEX, 0x3F,
    SSD1306_SETDISPLAYOFFSET, 0x00,
    SSD1306_SETSTARTLINE | 0x0,
    SSD1306_CHARGEPUMP, 0x14,
    SSD1306_MEMORYMODE, 0x00,
    SSD1306_SEGREMAP | 0x1,
    SSD1306_COMSCANDEC,
    SSD1306_SETCOMPINS, 0x12,
    SSD1306_SETCONTRAST, 0xCF,
    SSD1306_SETPRECHARGE, 0xF1,
    SSD1306_SETVCOMDETECT, 0x40,
    SSD1306_DISPLAYALLON_RESUME,
    SSD1306_NORMALDISPLAY,
    SSD1306_DISPLAYON
};

// Iniciação do display
void Display_init()
{
  Display_sendcmd (cmdInit, sizeof(cmdInit));
  Display_clear();
}

// Limpa o display
void Display_clear()
{
  // Define endereços iniciais e finais de colunas e páginas
  Display_sendcmd (SSD1306_COLUMNADDR);
  Display_sendcmd (0);
  Display_sendcmd (SSD1306_LCDWIDTH-1);
  Display_sendcmd (SSD1306_PAGEADDR);
  Display_sendcmd (0);
  Display_sendcmd (7);

  // Preenche a memória com zeros
  for (uint16_t i=0; i<((SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8)/16); i++) 
  {
      Wire.beginTransmission(DISP_ADDR);
      Wire.write(0x40);  // Co=0, DC = 1
      for (uint8_t x=0; x<16; x++) 
      {
          Wire.write(0);
      }
      Wire.endTransmission();
  }
}

// Envia sequência de comandos ao display
void Display_sendcmd (byte *cmd, int nCmds)
{
  Wire.beginTransmission(DISP_ADDR);
  Wire.write (0);  // Co= 0. DC = 0
  for (int i = 0; i < nCmds; i++)
  {
    Wire.write(cmd[i]);
  }
  Wire.endTransmission();
}

// Envia um byte de comando ao display
void Display_sendcmd (byte cmd)
{
  Wire.beginTransmission(DISP_ADDR);
  Wire.write (0);  // Co= 0. DC = 0
  Wire.write(cmd);
  Wire.endTransmission();
}
